---
title: "스마트팜 IoT 관리 시스템"
company: "대단"
period: "2025.09 - 2026.01"
role:
  - "풀스택 개발"
  - "아키텍처 설계"
  - "배포 환경 구성"
stack:
  - "Next.js"
  - "TypeScript"
  - "Spring Boot"
  - "PostgreSQL"
  - "MQTT"
  - "Docker"
  - "Nginx"
summary: "MQTT 기반 센서 데이터를 수집하여 농가 환경을 실시간으로 모니터링하는 스마트팜 관리 시스템"
problem: "MQTT 데이터 수집 시 웹 제어 API 응답 지연, 백엔드 재배포 시 알림 중복 발송, 실시간 데이터가 아닌 과거 데이터 우선 표시"
result:
  - "MQTT 데이터 수집 전용 백엔드 분리로 웹 제어 API 응답 속도 개선 및 시스템 책임 분리"
  - "알림 발송 상태 DB 저장으로 문자 비용 절감 및 알림 안정성 확보"
  - "타임스탬프 검증으로 실시간 데이터 정상 표시 및 사용자 이해도 향상"
thumbnail: "/images/projects/smartfarm-thumbnail.png"
featured: true
---

> **프로젝트 개요**
>
> 스마트팜 전용 관리 시스템이 필요해지면서 시작된 풀스택 프로젝트입니다. MQTT 기반으로 실시간 센서 데이터를 수집하고, 농가 현장에서 모바일로 환경을 제어할 수 있는 IoT 플랫폼입니다. 프론트엔드부터 백엔드, MQTT 데이터 수집, Docker 배포까지 전 영역을 설계하고 구현했으며, 운영 중 발생한 성능 이슈와 알림 중복 문제를 아키텍처 수정으로 해결했습니다.
>
> **프로젝트 성격**: 실시간 IoT 데이터 수집 환경에서 발생한 운영 이슈를 백엔드 책임 분리를 통해 구조적으로 해결한 아키텍처 개선 프로젝트

---

## 문제 상황 & 해결 경험

**문제**: MQTT 데이터 수집 시 웹 제어 API 응답 지연, 백엔드 재배포 시 알림 중복 발송, 실시간 데이터가 아닌 과거 데이터가 우선 표시되는 문제

**역할**: 풀스택 개발 / 프론트엔드 전반 설계 및 구현 / 백엔드 API 및 DB 구조 설계 / MQTT 기반 센서 데이터 수집·저장 및 웹 제어 API 연동 로직 설계 / Docker 기반 배포 환경 구성 및 운영

**결과**:
- MQTT 데이터 수집 전용 백엔드 분리로 웹 제어 API 응답 속도 개선 및 시스템 책임 분리
- 알림 상태 DB 저장으로 중복 발송 방지 및 비용 절감
- 타임스탬프 검증으로 실시간 데이터 정상 표시

---

## 아키텍처 결정

### 문제: 웹 API와 MQTT 수집이 동일 백엔드에서 경합

**선택지 비교**:

| 방안 | 장점 | 단점 | 선택 |
|------|------|------|------|
| 큐 기반 비동기 처리 | 기존 구조 유지, 코드 수정 최소 | 메모리 사용량 증가, 복잡도 상승, 근본 해결 아님 | ❌ |
| 스레드풀 크기 조정 | 즉시 적용 가능 | 트래픽 급증 시 여전히 지연 발생 | ❌ |
| **백엔드 분리** | 책임 분리, 독립 스케일링, 장애 격리 | 인프라 복잡도 증가, 데이터 동기화 필요 | ✅ |

**결정 이유**: 
- 단기 비용(인프라 복잡도)보다 장기 유지보수성 우선
- 센서 수 증가 시 MQTT 백엔드만 스케일 아웃 가능
- 웹 API 장애가 MQTT 수집에 영향을 주지 않음

---

기존 회사에서 스마트 공장 및 스마트 팩토리를 관리하던 사이트와는 별도로, 스마트팜만을 전문적으로 관리하는 시스템의 필요성이 대두되었습니다.

특히 다음과 같은 요구사항이 있었습니다:
- **사용자 친화적인 UI**: 기존 시스템은 PC 중심으로 설계되어 모바일 환경에서 사용하기 어려움
- **실시간 모니터링**: 농장 환경 센서 데이터를 실시간으로 확인하고 제어할 수 있어야 함
- **안정적인 알림**: 센서 이상 상황 발생 시 즉시 알림을 받아야 함

---

## 문제 상황

### 1. 웹 제어 API 응답 지연

**현상**: MQTT 데이터 수집이 진행되는 동안 웹 제어 API 요청이 지연되는 문제

**원인**:
- MQTT 데이터 수집 로직이 동기적으로 처리되어 웹 제어 API가 후순위로 밀림
- 단일 백엔드에서 데이터 수집과 웹 API를 동시에 처리하면서 리소스 경쟁 발생

### 2. 알림 중복 발송

**현상**: 백엔드 재배포 시 이미 발송된 알림이 중복으로 재발송되는 문제

**원인**:
- 알림 발송 상태를 메모리에서만 관리
- 재기동 시 상태가 초기화되면서 이전 알림 기록이 소실

**영향**:
- 불필요한 SMS 비용 증가
- 사용자에게 중복 알림으로 인한 혼란 발생

### 그 외 운영 이슈

실시간 데이터 표시 문제(MQTT retain 설정으로 과거 데이터 우선 수신), HMI 센서 설정 값 노출 문제 등을 타임스탬프 검증과 입력 단위 검증으로 해결했습니다.

---

## 선택지와 판단

### 문제 1: 웹 API 응답 지연 해결 방안

| 방안 | 장점 | 단점 | 선택 |
|------|------|------|------|
| 비동기 처리 강화 | 코드 변경 최소화 | 근본적인 리소스 경쟁 미해결 | ❌ |
| 스레드풀 크기 증가 | 간단한 설정 변경 | 서버 리소스 한계 | ❌ |
| **백엔드 분리** | 책임 분리, 장애 전파 방지 | 운영 복잡도 증가 | ✅ |

**선택 이유**:
- MQTT 데이터 수집과 웹 API는 성격이 다른 워크로드
- 각 서비스의 스케일링과 장애 대응을 독립적으로 수행 가능
- Docker 환경에서 서비스 분리가 용이

### 문제 2: 알림 상태 관리 방안

| 방안 | 장점 | 단점 | 선택 |
|------|------|------|------|
| Redis 캐시 | 빠른 조회 | 추가 인프라 필요 | ❌ |
| **DB 저장** | 영구 보존, 이력 추적 가능 | 약간의 성능 오버헤드 | ✅ |

**선택 이유**:
- 알림 발송 이력을 장기간 보관하여 문제 분석에 활용 가능
- 기존 PostgreSQL을 활용하여 추가 인프라 불필요

---

## 구현 포인트

### 1. 백엔드 아키텍처 분리

MQTT 수집과 웹 API를 서비스 레벨에서 완전히 분리하여 각 워크로드의 독립적인 스케일링과 장애 격리를 가능하게 한 구조입니다.

```
[센서] → [HMI] → [MQTT Broker]
                     ↓
        ┌────────────┴──────────────┐
        ↓                           ↓
[MQTT Collector Service]    [Web API Service]
        ↓                           ↓
    [PostgreSQL] ← ─ ─ ─ ─ ─ ─ ─ ─ ┘
                                    ↓
                              [프론트엔드]
```

### 2. MQTT 데이터 수집 서비스 분리

타임스탬프 검증을 통해 과거 데이터와 실시간 데이터를 구분하고, 실시간 데이터에만 즉시 처리 로직을 적용합니다.

```java
@Service
public class MqttMessageRouter {
  
  @MqttMessageHandler(topic = "v1/farm/+/device/+/data")
  public void handleSensorData(MqttPayload payload) {
    // 타임스탬프 검증
    if (isOldData(payload.getTimestamp())) {
      // 비동기 저장만 수행
      asyncPersistenceService.saveAsync(payload);
      return;
    }
    
    // 실시간 데이터는 즉시 저장 및 처리
    persistenceService.saveSensorData(payload);
    
    // 임계값 체크
    if (thresholdExceeded(payload)) {
      alertService.sendAlert(payload.getFarmId());
    }
  }
  
  private boolean isOldData(LocalDateTime timestamp) {
    return timestamp.isBefore(LocalDateTime.now().minusMinutes(5));
  }
}
```

### 3. 알림 상태 DB 저장

재배포 시에도 알림 상태를 유지하고 중복 발송을 방지하기 위해 최근 30분 이력을 DB에서 조회합니다.

```java
@Service
public class AlertService {
  
  public void sendAlert(Long farmId, String alertType) {
    // 최근 알림 발송 이력 확인
    Optional<AlertLog> recentAlert = alertLogRepository
      .findRecentAlert(farmId, alertType, LocalDateTime.now().minusMinutes(30));
    
    if (recentAlert.isPresent()) {
      log.info("Alert already sent within 30 minutes, skipping");
      return;
    }
    
    // SMS 발송
    smsService.send(farmId, alertType);
    
    // 발송 이력 저장
    alertLogRepository.save(AlertLog.builder()
      .farmId(farmId)
      .alertType(alertType)
      .sentAt(LocalDateTime.now())
      .build());
  }
}
```

### 4. Docker Compose 구성

web-api와 mqtt-collector를 독립된 컨테이너로 분리하여 각 서비스를 독립적으로 배포하고 스케일링할 수 있도록 구성했습니다.

```yaml
version: '3.8'
services:
  web-api:
    image: smartfarm-web-api:latest
    ports:
      - "8080:8080"
    environment:
      - SPRING_PROFILES_ACTIVE=prod
    depends_on:
      - postgres
  
  mqtt-collector:
    image: smartfarm-mqtt-collector:latest
    environment:
      - MQTT_BROKER_URL=tcp://mqtt-broker:1883
    depends_on:
      - postgres
      - mqtt-broker
  
  postgres:
    image: postgres:14
    volumes:
      - postgres-data:/var/lib/postgresql/data
  
  mqtt-broker:
    image: eclipse-mosquitto:2
    ports:
      - "1883:1883"
```

---

## 결과

### 정량적 성과
- **응답 속도**: 웹 제어 API 응답 시간 안정화 (데이터 수집 시에도 일정한 응답 속도 유지)
- **비용 절감**: SMS 중복 발송 방지로 월간 문자 비용 절감
- **안정성**: 백엔드 재배포 시에도 알림 상태 유지
- **사용자 경험**: 실시간 데이터 정상 표시 및 입력 검증으로 사용자 이해도 향상

### 정성적 성과
- 실제 스마트팜 운영을 목표로 시스템을 설계·구현하며, MQTT 기반 데이터 수집, 알림, 웹 제어 영역에서 발생 가능한 주요 운영 리스크를 사전에 식별하고 구조적으로 대응
- 현장별로 상이한 센서 구성과 데이터 포맷이 표준화되어 있지 않은 환경에서, 단일 시스템으로의 즉각적인 실운영보다는 구조적 안정성과 확장 가능성 검증에 우선순위를 두고 개발 진행
- 센서 표준화 및 운영 기준 합의가 선행되어야 실운영 단계로 자연스럽게 확장될 수 있음을 기술적으로 검증

---

## 회고

### 잘한 점
- **책임 분리 원칙 적용**: MQTT 데이터 수집과 웹 API를 분리하여 각 서비스의 독립성 확보
- **문제 원인 정확한 파악**: 메모리 기반 상태 관리 → DB 저장으로 근본적인 문제 해결
- **운영 환경 고려**: Docker를 활용한 표준화된 배포 환경 구성
- **사용자 경험 고려**: 입력 단위 검증, 가이드 문구, 기본값 설계로 사용자 실수 방지

### 아쉬운 점
- 실시간 시스템에서는 동기/비동기 경계를 명확히 나누지 않으면 사용자 제어 API 안정성에 직접적인 영향을 준다는 점을 초기에 인식하지 못함
- 향후 앱 형태로 확장 시 사용자 경험 개선 가능성 존재

### 배운 점
- **실시간 IoT 시스템의 운영 리스크**: 운영 리스크를 구조로 분리해 안정화하는 것의 중요성
- **동기/비동기 처리 전략**: 실시간 시스템에서 동기/비동기 경계를 명확히 나누지 않으면 사용자 제어 API 안정성에 직접적인 영향을 준다는 점 체감
- **표준화의 중요성**: 센서 표준화 및 운영 기준 합의가 선행되어야 실운영 단계로 자연스럽게 확장될 수 있음
- **책임 분리 원칙**: 이 프로젝트에서 확립한 "성격이 다른 워크로드는 서비스 레벨에서 분리" 원칙은 이후 다른 실시간 시스템 설계에서도 아키텍처 기준으로 적용되었습니다
