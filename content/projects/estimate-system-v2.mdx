---
title: "스마트팜 견적 시스템 2차 - 프리셋 모드"
company: "대단"
period: "2025.05 - 2025.08"
role:
  - "풀스택 개발"
  - "프리셋 구조 설계"
stack:
  - "Vue 3"
  - "TypeScript"
  - "Capacitor"
  - "Node.js"
  - "PostgreSQL"
  - "pm2"
  - "Nginx"
summary: "스마트팜을 설치하는 고객의 환경에 따라 변경될 수 있는 예상 견적 시스템 - 견적 항목·자재 구성·계산 규칙을 프리셋 단위로 관리"
problem: "1차 시스템 운영 중 견적 항목과 계산 규칙이 지속적으로 변경되며 유지보수 비용 증가"
result:
  - "프리셋 재사용성과 계산 정확도를 동시에 확보하며 고객 환경별 견적 산출 신뢰도 향상"
  - "신규 항목 추가 시 코드 수정 없이 대응 가능해졌으며 계산 로직의 유지보수성과 확장성 확보"
  - "기술적 구현 이전에 현장 기준 및 계산 규칙의 합의·표준화가 선행되어야 함을 검증"
thumbnail: "/images/projects/estimate-v2-thumbnail.png"
featured: true
---

> **프로젝트 개요**
>
> 1차 견적 시스템 운영 중 견적 규칙이 지속적으로 변경되면서 시작된 프로젝트입니다. 견적 항목·자재 구성·계산 규칙을 프리셋 데이터로 관리하는 확장형 견적 시스템입니다. 코드 수정 없이 영업팀이 규칙을 변경할 수 있도록 설계했으며, 단독 개발 환경에서 프론트엔드·백엔드·DB 구조를 전담했습니다.
>
> **프로젝트 성격**: 비즈니스 규칙 변경에 대응하기 위해 로직을 코드가 아닌 데이터로 관리하는 구조 설계 프로젝트

---

## 문제 상황 & 해결 경험

**문제**: 1차 견적 시스템 운영 중 견적 항목과 계산 규칙이 지속적으로 변경되며 유지보수 비용과 오류 발생 가능성 증가

**역할**: 풀스택 개발 / 프론트엔드·백엔드 전반 설계 및 구현 / 백엔드 API 및 DB 구조 설계 / Capacitor를 활용한 하이브리드 앱 전환 구성 / 단독 개발

**결과**:
- 프리셋 재사용성과 계산 정확도를 동시에 확보하며 고객 환경별 견적 산출 신뢰도 향상
- 신규 항목 추가 시 코드 수정 없이 대응 가능해졌으며 계산 로직의 유지보수성과 확장성 확보
- 기술과 도메인 표준화의 선후관계 명확히 인식

---

## 아키텍처 결정

### 문제: 견적 규칙 변경마다 코드 수정 및 배포 필요

**선택지 비교**:

| 방안 | 장점 | 단점 | 선택 |
|------|------|------|------|
| 코드 기반 관리 (1차 방식) | 구현 간단, 즉시 적용 | 규칙 변경 시 배포 필요, 회귀 테스트 부담 | ❌ |
| **프리셋 기반 관리** | 코드 수정 없이 규칙 변경, 영업팀 직접 관리 가능 | 데이터 설계 복잡도 증가 | ✅ |
| 룰 엔진 도입 | 고도의 유연성, 복잡한 규칙 표현 | 학습 곡선 높음, 오버엔지니어링 | ❌ |

**결정 이유**:
- 영업 현장의 견적 기준 변경 빈도가 높아 유연성 확보 필수
- 단독 개발 환경에서 구현 가능한 적절한 복잡도
- 향후 영업팀이 직접 프리셋 관리 가능한 구조

---

1차 영업용 견적 시스템 운영 과정에서 드러난 문제점:

- **견적 규칙의 잦은 변경**: 견적 항목과 계산 규칙이 지속적으로 변경
- **코드 수정 부담**: 규칙 변경 시마다 코드를 수정해야 하며, 유지보수 비용과 오류 발생 가능성 증가
- **영업 현장별 차이**: 견적 항목·자재 구성·계산 규칙을 하나의 프리셋 단위로 관리함으로써 견적 산출 과정을 표준화
- **시스템 구조 목표**: 영업 현장별로 상이한 견적 기준을 시스템적으로 흡수할 수 있는 구조

이러한 문제를 근본적으로 해결하기 위해, 영업팀과의 반복 협의를 통해 프리셋 기준값과 계산 규칙의 최소 공통 기준을 정립하고, **견적 항목·자재 구성·계산 규칙을 코드가 아닌 데이터(프리셋)로 관리**하는 2차 시스템을 기획했습니다.

---

## 선택지와 판단

### 견적 규칙 관리 방안

| 방안 | 장점 | 단점 | 선택 |
|------|------|------|------|
| 코드 기반 관리 (1차 방식) | 구현 간단 | 규칙 변경 시 배포 필요 | ❌ |
| **프리셋 기반 관리** | 코드 수정 없이 규칙 변경 가능 | 데이터 설계 복잡도 증가 | ✅ |
| 룰 엔진 도입 | 고도의 유연성 | 학습 곡선 높음, 오버엔지니어링 | ❌ |

**선택 이유**:
- 영업팀이 직접 프리셋을 관리할 수 있는 구조
- 코드 배포 없이 견적 기준 변경 가능
- 고객 환경에 따라 달라지는 자재 구성과 계산 방식을 유연하게 반영
- 현장 활용성을 고려해 웹 기반 구현 후 Capacitor를 활용한 앱 확장
- 단독 개발 환경에서 안정적인 운영을 위해 pm2 기반 백엔드 프로세스 관리 선택

---

## 문제 상황 & 해결

### 1. 프리셋 기준값과 실제 입력값의 차이 보정

**현상**: 프리셋에 정의된 기준 면적과 실제 고객 입력 면적이 다를 경우, 일부 자재 수량이 실제 설치 환경과 맞지 않는 계산 결과가 발생

**원인**: 
- 프리셋 기준값과 실제 입력값을 동일한 계산 기준으로 처리
- 환경 차이를 흡수하지 못하는 구조적 한계 존재

**해결**:
- 프리셋 기준값과 실제 입력값을 분리
- 차이를 보정하는 규칙을 데이터로 관리하도록 구조 개선

**결과**:
- 프리셋 재사용성과 계산 정확도를 동시에 확보
- 고객 환경별 견적 산출 신뢰도 향상

### 2. 자재·노무비 항목별 상이한 적용 기준

**현상**: 자재·노무비 항목마다 적용 기준이 상이하여 로직 복잡도 증가

**원인**: 
- 모든 항목을 동일한 계산 흐름으로 처리하려는 초기 설계
- 도메인 차이를 코드로 흡수하고 있었음

**해결 - 계산 타입별 프리셋 데이터 구조**:

각 자재가 어떤 방식으로 계산되는지(평당/고정/구간별) 타입을 명시하여 로직 분기를 데이터로 제어합니다.

```typescript
interface MaterialPreset {
  id: number;
  name: string;
  calculationType: 'PER_AREA' | 'FIXED' | 'RANGE_BASED';
  unitPerArea?: number;  // PER_AREA 타입일 때
  fixedQuantity?: number;  // FIXED 타입일 때
  rangeRules?: Array<{  // RANGE_BASED 타입일 때
    minArea: number;
    maxArea: number;
    quantity: number;
  }>;
}

// 예시 데이터
const materials: MaterialPreset[] = [
  {
    id: 1,
    name: '센서',
    calculationType: 'PER_AREA',
    unitPerArea: 0.5  // 평당 0.5개
  },
  {
    id: 2,
    name: '제어기',
    calculationType: 'FIXED',
    fixedQuantity: 1  // 평수와 무관하게 1개
  },
  {
    id: 3,
    name: '배관',
    calculationType: 'RANGE_BASED',
    rangeRules: [
      { minArea: 0, maxArea: 50, quantity: 10 },
      { minArea: 51, maxArea: 100, quantity: 15 },
      { minArea: 101, maxArea: Infinity, quantity: 20 }
    ]
  }
];
```

**결과**:
- 항목별 계산 타입을 데이터로 분리
- 계산 방식에 따라 로직을 단순화하는 구조로 재설계
- 신규 항목 추가 시 코드 수정 없이 대응 가능
- 계산 로직의 유지보수성과 확장성 확보

### 그 외 UX 개선

이익률 일괄 적용, 프리셋 복사 생성 등 반복 입력을 줄이는 기능을 추가하여 영업팀의 프리셋 관리 시간을 단축했습니다.

---

## 구현 포인트

### 1. 프리셋 기반 견적 계산 엔진

calculationType에 따라 수량을 다르게 계산하는 엔진 구조로, 신규 계산 방식 추가 시에도 기존 로직을 수정하지 않도록 설계했습니다.

```typescript
class EstimateCalculator {
  calculate(preset: Preset, area: number): EstimateResult {
    const materials = this.calculateMaterials(preset.materials, area);
    const labor = this.calculateLabor(preset.labor, area);
    const total = materials + labor;
    const profit = total * (preset.profitRate / 100);
    
    return {
      materials,
      labor,
      subtotal: total,
      profit,
      total: total + profit
    };
  }
  
  private calculateMaterials(materials: MaterialPreset[], area: number): number {
    return materials.reduce((sum, material) => {
      const quantity = this.getQuantity(material, area);
      return sum + (quantity * material.unitPrice);
    }, 0);
  }
  
  private getQuantity(material: MaterialPreset, area: number): number {
    switch (material.calculationType) {
      case 'PER_AREA':
        return area * material.unitPerArea!;
      case 'FIXED':
        return material.fixedQuantity!;
      case 'RANGE_BASED':
        const rule = material.rangeRules!.find(r => 
          area >= r.minArea && area <= r.maxArea
        );
        return rule?.quantity || 0;
      default:
        return 0;
    }
  }
}
```

### 2. 프리셋 관리 DB 스키마

프리셋·자재·구간별 규칙을 3개 테이블로 정규화하여 데이터 일관성을 유지하면서도 확장 가능하도록 구성했습니다.

```sql
-- 프리셋 마스터
CREATE TABLE presets (
  id SERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  description TEXT,
  profit_rate DECIMAL(5, 2),
  created_at TIMESTAMP DEFAULT NOW()
);

-- 자재 항목
CREATE TABLE preset_materials (
  id SERIAL PRIMARY KEY,
  preset_id INT REFERENCES presets(id),
  name VARCHAR(100) NOT NULL,
  calculation_type VARCHAR(20) NOT NULL, -- PER_AREA, FIXED, RANGE_BASED
  unit_per_area DECIMAL(10, 2),
  fixed_quantity INT,
  unit_price DECIMAL(10, 2) NOT NULL
);

-- 구간별 규칙
CREATE TABLE material_range_rules (
  id SERIAL PRIMARY KEY,
  material_id INT REFERENCES preset_materials(id),
  min_area INT NOT NULL,
  max_area INT NOT NULL,
  quantity INT NOT NULL
);
```

---

## 결과

### 정량적 성과
- 견적 규칙 변경 시 코드 수정 불필요 (0회 배포)
- 프리셋 입력 시간 단축 (이익률 일괄 적용)
- 신규 견적 유형 추가 시 기존 로직 수정 없이 확장 가능함을 검증

### 정성적 성과
- 프리셋 단위로 계산 규칙을 분리하며, 신규 견적 유형 추가 시 기존 로직 수정 없이 확장 가능함을 검증
- 기술적 구현 이전에, **현장 기준 및 계산 규칙의 합의·표준화가 선행되어야 함**을 검증
- 기술적 완성도와 별개로, 견적 항목과 계산 규칙에 대한 조직 차원의 표준화가 선행되지 않아 실사용으로 이어지지 못했으나, 기술로 해결할 수 있는 영역과 조직·도메인 차원의 합의가 필요한 영역을 구분하게 된 중요한 경험

---

## 회고

### 잘한 점
- **확장 가능한 구조 설계**: 프리셋 기반으로 다양한 계산 규칙 수용
- **사용성 개선**: 이익률 일괄 적용 등 실제 사용 편의성 고려
- **도메인 복잡성 인식**: 기술로 해결할 수 있는 영역과 조직·도메인 차원의 합의가 필요한 영역을 구분하게 된 경험

### 아쉬운 점
- **실사용 미달성**: 기술적 완성도와 별개로, 견적 항목과 계산 규칙에 대한 조직 차원의 표준화가 선행되지 않아 실사용으로 이어지지 못함
- 향후 앱 형태로 확장 시 사용자 경험 개선 가능성 인식

### 배운 점
- **기술과 비즈니스의 경계**: 기술로 해결할 수 있는 영역과, 조직·도메인 차원의 합의가 필요한 영역을 구분
- **복잡성 관리**: 견적 계산 규칙의 복잡성과 도메인 의존성을 명확히 인식
- **표준화의 중요성**: 시스템 도입 전 비즈니스 프로세스 표준화가 먼저 필요함을 검증
- **설계 기준 확립**: 이 경험을 통해 확립한 "비즈니스 규칙은 데이터로 관리" 원칙은 이후 다른 프로젝트에서도 아키텍처 설계 기준으로 활용되었습니다
